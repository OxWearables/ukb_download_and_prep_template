#######################
Advanced usage
#######################
***********************************************
Manually adding a field to :code:`columns.json`
***********************************************

Rather than relying on the autogenerated :code:`columns.json` file, we can manually update it e.g. to add a particular column.

For example, to add :code:`1558` (alcohol intake frequency), open :code:`columns.json` and add:

.. code-block:: JSON

   {
    # ...
    "1558-0.0":{} #,
    # ...
   }

Then after running :code:`python filterUKB.py...` your output CSV will have a column that looks like this:

+----------------------------+
| AlcoholIntakFrequenc       |
+============================+
| Three or four times a week |
+----------------------------+
| Special occasions only     |
+----------------------------+
| One to three times a month |
+----------------------------+
| One to three times a month |
+----------------------------+
| Daily or almost daily      |
+----------------------------+
| Never                      |
+----------------------------+
| ...                        |
+----------------------------+

*********************************************
Specifying particular relabelling or recoding 
*********************************************
The tool automatically renames columns and recodes categorical variables.  This is using UK Biobank's Data Dictionary and coding schema (:code:`Data_Dictionary_Showcase.csv` and :code:`Codings_Showcase.csv`; available from UK Biobank's website). 

For the column name parsing, it uses UKB's field description, which works reasonably well unless the description is very long. For example, :code:`6153` (medication for cholesterol, blood pressure, diabetes, or take exogenous hormones) gets the mouthful :code:`MedCholesterolBloodPressDiabetTakExogHormon`

It is possible to customize the column name by specifying a :code:`name` key. It is also possible to customize the categorical values (e.g. if you want to recategorize) by specifying a :code:`replace_values` key. In the last example, further editing :code:`columns.json` to say: 

.. code-block:: json

        {
            # ...
            "1558-0.0":{
                'name': 'Booze',
                'replace_values': {
                    1: "weekly",  # Daily or almost daily
                    2: "weekly",  # 3-4 times a week
                    3: "weekly",  # 1-2 times a week
                    4: "rarely",  # 1-3 times a month
                    5: "rarely",  # Special occasions only
                    6: "never",   # Never
                   -3: np.nan,    # Prefer not to answer
                }
            }# ,
            # ...
        }

and running :code:`filterUKB.py` as above will convert the previous column to

+----------------------------+
| Booze                      |
+============================+
| weekly                     |
+----------------------------+
| rarely                     |
+----------------------------+
| rarely                     |
+----------------------------+
| rarely                     |
+----------------------------+
| weekly                     |
+----------------------------+
| never                      |
+----------------------------+
| ...                        |
+----------------------------+


**********************
Adding derived columns
**********************

You might have to create new columns based on operations on other columns. To use this option, :code:`filterUKB.py` must be run with the optional argument :code:`--derived_columns True`. 

The :code:`derivedColumns.json` file is used to specify the operations used to create columns. The file included in this folder contains some common options to derive. 

For example, there are (confusingly) three columns corresponding to date of death: :code:`40001-0.0`, :code:`40001-1.0` and :code:`40001-2.0`. It makes sense that the earliest of these is the date of death. To do this, open :code:`derivedColumns.json` and add:

.. code-block:: json

   {
        "DateOfDeath": {
                "columns": ["40000-0.0", "40000-1.0"],
                "func": "lambda df: df.astype('datetime64').min(axis=1)"
        }
   }


The :code:`"columns"` key defines which columns of the raw UKB table to select, and :code:`"func"` defines the function to operate on the resulting subtable. [Alternatively, you can omit :code:`"columns"` and write :code:`"func"` directly as :code:`"lambda df: df[['40000-0.0', '40000-1.0', '40000-2.0']].astype('datetime64').min(axis=1)"`]. 

Your output CSV will now have a column that looks like this:

+----------------------------+
| DateOfDeath                |
+============================+
| 2013-08-17                 |
+----------------------------+
| NaN                        |
+----------------------------+
| NaN                        |
+----------------------------+
| 2015-03-07                 |
+----------------------------+
| NaN                        |
+----------------------------+
| ...                        |
+----------------------------+

See :code:`derivedColumns.json` for more examples.

************************************************
Working with multiple :code:`ukbXXXX.csv` files
************************************************
Sometimes we have multiple UKB files because we requested more variables later during the project and these extra variables come separately. In that case, the tool can take multiple UKB files:

.. code-block:: sh

   python filterUKB.py ukb12345.csv ukb54321.csv -o outputFilename.csv

***************************
Including field ID suffixes
***************************

When automatically parsing the field ID, by default it will drop the suffixes :code:`-X.Y` (indicating visit number and array index, for example :code:`-0.0`, :code:`-1.0`, etc). If you need to keep these, set the key :code:`drop_suffix=False` and it will append the suffixes as :code:`_X_Y`. For example,

.. code-block:: json

   {
    # ...
    "1558-0.0":{
        "drop_suffix": False,
        } #,
    # ...
    }

will produce the column name :code:`AlcoholIntakFrequenc_0_0`.

******************
Disabling parsing
******************

If for some reason you don't want to automatically parse the field ID and/or the categorical codes, you can explicitly set the keys :code:`name` and/or :code:`replace_values` to :code:`None`. For example,

.. code-block:: json 

   {
    # ...
     "1558-0.0":{
        "name": None,
        "replace_values": None,
     },
     # ...
    }

will leave the column untouched:

+----------+
| 1558-0.0 |
+==========+
| 2        |
+----------+
| 2        |
+----------+
| 4        |
+----------+
| 6        |
+----------+
| 1        |
+----------+
| 6        |
+----------+
| ...      |
+----------+

**************************************
An alternative for R/ SAS/ Stata users
**************************************

If you prefer to use R, SAS or Stata for data preparation, UK Biobank has a built-in tool to facilitate this. However, note this tool doesn't have the column-renaming functionality and additional flexibility on recoding implemented as part of this tool.  

For example, to use R: 

.. code-block:: sh
 
  download/helpers/linux_tools/ukb_conv path_to_data/ukb12345.enc_ukb r -ianalysisCols.txt
  # output = path_to_data/ukb12345.r
  # output = path_to_data/ukb12345.tab
   
:code:`ukb12345.r` can be opened and run in R: it will automatically recode - but not rename - categorical columns.  


   
